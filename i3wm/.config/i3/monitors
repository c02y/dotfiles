#!/bin/env bash

# NOTE: TODO: FIXME: xrandr can only detect if a monitor is connected or not,
# it cannot detect if a monitor is powered on or off, solution not found yet:
# https://bbs.archlinux.org/viewtopic.php?id=257700

# if accicdently disable all monitors: switch to tty using Ctrl-Alt-F2
# run `sleep 2 && xrandr -d :0 --auto`, before sleep is finished, switch to workspace(Ctrl-Alt-F7)

# only handle situations with only external monitor and laptop builtin monitor
# enhance it when more monitors are available

function help() {
	echo -e "\n\e[1mNAME\e[0m"
	echo -e "\tmonitors - manager monitors"
	echo -e ""
	echo -e "\e[1mSYNOPSIS\e[0m"
	echo -e "\tmonitors [OPTIONS]"
	echo -e ""
	echo -e "\e[1mDESCRIPTION\e[0m"
	echo -e ""
	echo -e "\e[1mOPTIONS\e[0m"
	echo -e "\tno-flag\tChoose the external(the only one) monitor"
	echo -e "\t-0\tEnable only the latop native builtin monitor"
	echo -e "\t-1\tEnable only the external(the only one) monitor"
	echo -e "\t-2\tEnable both the latop native builtin and external monitors"
	echo -e "\t-l\tList all the connected monitors"
	echo -e "\t-h\tPrint this usage"
	echo -e ""
	echo -e "\e[1mOTHER\e[0m"
	echo -e "\t~/.screenz is generated by this program to store the parameters for your monitors/layouts."
	echo -e ""
}

# FIXME: only test two monitors, and --left-of may have issues
function monitors_all() {
	# NOTE: `xrandr --auto` will enable all monitors as possible, but it won't handle the layout, for instance,
	# external monitor may only use part of the big screen, laptop's builtin small screen will be the main monitor
	monitors=$(xrandr | awk '$2 == "connected"{print $1}')
	monitors_resolutions_list=$(xrandr | grep -A 1 ' connected ' --no-group-separator | awk '{print $1}')
	max_resolution=$(echo "$monitors_resolutions_list" | grep x | sort -nr | head -1)
	max_resolution_monitor=$(echo "$monitors_resolutions_list" | grep -B 1 "$max_resolution" | head -1)
	monitors_on_list=$(xrandr | grep -E " connected (primary )?[1-9]+" | sed -e "s/\([A-Z0-9]\+\) connected.*/\1/")
	if [[ "$monitors_on_list" != *"$max_resolution_monitor"* ]]; then
		xrandr --output "$max_resolution_monitor" --auto
	fi
	for monitor in $monitors; do
		if [[ "$monitor" != "$max_resolution_monitor" || "$monitors_on_list" != *"$monitor"* ]]; then
			xrandr --output "$monitor" --right-of "$max_resolution_monitor" --auto
		fi
	done
}

# FIXME: not perfect, sometimes it messes up the primary monitor
function monitors_choose() {
	monitors_list
	monitors=$(xrandr | awk '$2 == "connected"{print $1}')

	while true; do
		read -r -e -p 'Which monitor to enable? (primary first) '
		# avoid Space or Enter input
		if [[ "$REPLY" == "" || "$REPLY" == " " ]]; then
			echo "Need input monitor, start over!"
			continue
		fi
		for reply in $REPLY; do
			if ! echo "$monitors" | grep -q "$reply"; then
				echo "$reply is not available, start over!"
				continue 2
			fi
		done

		# if provided multiple monitors to be enabled
		# TODO: choose the max resolution monitor
		if [[ "$REPLY" = *" "* ]]; then
			OPT="--noprimary --output $(echo $REPLY | awk '{print $1}') --auto"

			# get the words in REPLY except the first one
			# DO NOTE QUOTE it
			REPLY2=($REPLY)
			for reply in "${REPLY2[@]:1}"; do # start for loop for the second element
				# NOTE: only test two monitors about the --left-of
				OPT+=" --output $reply --left-of $REPLY2 --auto"
			done
			eval xrandr "$OPT"
		else
			xrandr --noprimary --output "$REPLY" --auto
		fi

		disabled=$(echo "${monitors[@]}" "${REPLY[@]}" | sed 's/ /\n/g' | sort | uniq -u)
		for monitor in $disabled; do
			xrandr --noprimary --output "$monitor" --off
		done
		break
	done
}

function monitors_single() {
	monitors=$(xrandr | awk '$2 == "connected"{print $1}')
	# NOTE: don't know how xrandr auto choose the "primary" monitor

	monitors_resolutions_list=$(xrandr | grep -A 1 ' connected ' --no-group-separator | awk '{print $1}')
	max_resolution=$(echo "$monitors_resolutions_list" | grep x | sort -nr | head -1)
	max_resolution_monitor=$(echo "$monitors_resolutions_list" | grep -B 1 "$max_resolution" | head -1)

	for monitor in $monitors; do
		if [[ "$monitor" != *"$max_resolution_monitor"* ]]; then
			xrandr --output "$monitor" --off
		fi
	done

	monitors_on_list=$(xrandr | grep -E " connected (primary )?[1-9]+" | sed -e "s/\([A-Z0-9]\+\) connected.*/\1/")
	if [[ "$monitors_on_list" != *"$max_resolution_monitor"* ]]; then
		xrandr --noprimary --output "$max_resolution_monitor" --auto
	fi
}

function monitors_list() {
	# the grep part is to highlight the matches and print the whole output as well
	xrandr | grep --color ' connected \|$'
	echo -e "\nCurrently enabled:\n$(xrandr | grep -E ' connected (primary )?[1-9]+')"
}

# NOTE: the following part is simpified version of all above functions,
# it is specified for one environment with exact monitors IDs from xrandr
# FIXME: no solution to find out in bash script which one is the laptop's builtin native monitor
function monitors_specify() {
	monitor_external0="DP-0"
	monitor_laptop="DP-2"
	laptop_2_external0="--right-of"

	if ! xrandr | grep -q "$monitor_external0 connected"; then
		xrandr --output "$monitor_laptop" --auto --primary
		return
	fi
	monitors_on_list=$(xrandr | grep -E " connected (primary )?[1-9]+" | sed -e "s/\([A-Z0-9]\+\) connected.*/\1/")
	case "$1" in
	"0")
		if [[ "$monitors_on_list" != "$monitor_laptop" ]]; then
			xrandr --output "$monitor_laptop" --auto --primary --output "$monitor_external0" --off
		fi
		;;
	"1")
		if [[ "$monitors_on_list" != "$monitor_external0" ]]; then
			xrandr --output "$monitor_external0" --primary --auto --output "$monitor_laptop" --off
		fi
		;;
	"2")
		xrandr --output "$monitor_external0" --auto --primary --output "$monitor_laptop" --auto "$laptop_2_external0" "$monitor_external0"
		;;
	"*")
		echo "Wrong arguments!"
		;;
	esac
}

case $1 in
"-h")
	help
	;;
"-0")
	monitors_specify 0
	;;
"-1")
	monitors_specify 1
	;;
"-2")
	monitors_specify 2
	;;
"-l")
	monitors_list
	;;
"-c")
	monitors_choose
	;;
"-a")
	monitors_all
	;;
*)
	if [[ -n $1 ]]; then
		help
	else
		monitors_specify 1
	fi
	;;
esac
